# Фиксация объектов в памяти
Для опроса футур, они должны быть закреплены в памяти с помощью специального типа `Pin<T>`. Если вы посмотрите на сигнатуру типаж `Future`, то увидите что в методе `poll`, `self` определена как `Pin<&mut Self>`. Но что это означает и зачем это нужно?

## Зачем нужна фиксация объектов в памяти
`Pin` работает в тандеме с маркером `Unpin`. Фиксация делает возможным гарантировать что объект, который не реализует `Unpin` не будет перемещен в памяти. Для понимания зачем это необходимо, нужно вспомнить как работает `async`/`.await`. Рассмотрим следующий код:

```rust,edition2018,ignore
let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
```

Здесь создается анонимный тип который реализует типаж `Future`, и который реализует метод `poll` примерно так:

```rust,ignore
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

Когда метод `poll` вызывается первый раз, он опрашивает `fut_one`. Если `fut_one` не завершена то возвращается `Poll::Pending`. Следующий вызов `poll` продолжит работу ровно с того места где остановился предыдущий вызов. Этот процесс будет выполнятся до тех пор пока `Future` не будет полностью завершена.

Но что будет если `async` блок содержит ссылки?
Например:

```rust,edition2018,ignore
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

Во что будет преобразован этот код?

```rust,ignore
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

Здесь, `AsyncFuture` представляет собой самореферентную структуру, где поле `read_into_buf_fut` содержит ссылку на поле `x`. Поэтому если `AsyncFuture` переместится в памяти, то и `x` тоже переместится, таким образом указатель `read_into_buf_fut.buf` станет не валидным.

Фиксация футур в памяти позволяет избежать этих проблем, делая безопасным использование ссылок внутри `async` блоков.

## Фиксация в деталях

Давайте попробуем разобраться в фиксации используя простой пример.
Проблема, с которой мы столкнулись выше, сводится к тому, как мы обрабатываем ссылки в самореферентных типах в Rust.

Для начала наш пример будет выглядеть так:

```rust, ignore
#[derive(Debug)]
pub struct Test {
    a: String,
    b: *const String,
}

impl Test {
    pub fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    pub fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    pub fn a(&self) -> &str {
        &self.a
    }

    pub fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Структура `Test` реализует методы для доступа к полям `a` и `b`. Поскольку `b` ссылается на `a`, мы вынуждены храним указатель на `a`, поскольку контроль заимствования в Rust не позволяет нам указать времени жизни для `b`. Теперь у нас есть то, что мы называем самореферентной структурой. 

Наш пример отлично работает ровно до тех пор пока мы не перемещаем в памяти нашу структуру `Test`:

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

Мы получаем то что ожидали:

```rust, ignore
a: test1, b: test1
a: test2, b: test2
```

Теперь давайте посмотрим что случится если мы поменяем местами в памяти `test1` и `test2` и тем самым переместим данные:

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());
}
```

Мы, наивно, пологали получить:

```rust, ignore
a: test2, b: test2
a: test1, b: test1
```

однако получили:

```rust, ignore
a: test2, b: test1
a: test1, b: test2
```

Потому-что, указатели `test1.b` и `test2.b` попрежнему указывают на старое рсположение `a` своих экземпляров. Структура перестала быть самореферентной, она содержит указатель на поле другого объекта. Это означает, что мы не можем больше полагаться на то, что время жизни test1.b будет связано со временем жизни test1.

## Фиксация на практике
Давайте посмотрим как фиксация в общем и тип `Pin` в частности помогут решить наши задачи.

Тип `Pin` оборачивает типы с указателем, при этом гарантируя что сам объект не будет перемещен в памяти. Например `Pin<&mut T>`, `Pin<&T>`, `Pin<Box<T>>` гарантирует что `T` не будет перемещен, если он не реализует типаж `Unpin`.

Большинство типов не имеют проблем с перемещением. Эти типы реализуют типаж `Unpin`. Указатели на `Unpin` типы могу свободно вставляться и извлекаться из `Pin`. Например, `u8` реализует `Unpin`, поэтому `Pin<&mut u8>` ведет себя так-же как и `&mut u8`.

Тем не менее, типы которые не реализуют `Unpin`, нельзя перемещать после того как они зафиксированы в памяти. Примером этого является тип, созданный с помощью async / await.

### Фиксация на стеке
Вернемся к нашему примеру. Мы можем решить нашу проблему используя `Pin`. Давайте посмотрим, как выглядел бы наш пример, если бы нам потребовался зафиксированный указатель:

```rust, ignore
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }
    fn init<'a>(self: Pin<&'a mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Фиксация объекта на стеке всегда `unsafe` если ваш тип не реализует `Unpin`. Вы можите использовать крейт `pin_utils` для того что-бы не писать `unsafe` самому.

Ниже, мы закрепили объекты `test1` и `test2` на стеке:

```rust
pub fn main() {
    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

Теперь, мы попробуем переместить объекты в памяти и получим ошибку компиляции:

```rust, compile_fail
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

Система типов `Rust` запретит нам перемещать объекты в памяти.

> Важно отметить, что фиксация объектов на стеке, всегда зависит от гараний которые вы предоставили в `unsafe` блоке.
> Хотя мы знаем, что указатель `&'a mut T` зафиксирован в течении времени жизни `'a`, мы не можем знать, не перемещаются ли данные `&'a mut T`, на которые указывает `'a`, после завершения `'a`.
> Если это произойдет, это приведет к нарушению `Pin`-контракта.
>
> Ошибка, которую легко сделать - это забыть затенить исходную переменную, поскольку вы можете отбросить Пин и переместить данные после & 'a mut T, как показано ниже (что нарушает контракт Пина):
>
> ```rust
> fn main() {
>    let mut test1 = Test::new("test1");
>    let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
>    Test::init(test1_pin.as_mut());
>    drop(test1_pin);
>    println!(r#"test1.b points to "test1": {:?}..."#, test1.b);
>    let mut test2 = Test::new("test2");
>    mem::swap(&mut test1, &mut test2);
>    println!("... and now it points nowhere: {:?}", test1.b);
> }
> ```

### Фиксация объектов в куче
Фиксация типов не реализующих `Unpin` в куче дает нашим объектам постоянный адрес в памяти, поэтому мы знаем, что данные на которые мы указываем, не могут перемещаться после фиксации. В отличие от фиксации на стеке, мы знаем, что данные будут зафиксированы на все время существования объекта.

```rust, edition2018
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

Некоторые функции требуют открепления Футур, с которыми они работают. Чтобы использовать `Future` или `Stream`, которые не являются `Unpin`, с функцией, требующей типов `Unpin`, вам сначала нужно закрепить значение, используя либо `Box::pin` (для создания `Pin<Box <T>>`), либо `pin_utils::pin_mut!` макрос (для создания `Pin<&mut T>`). `Pin<Box<Fut>>` и `Pin<& mut Fut>` могут использоваться как Футуры, и оба реализуют `Unpin`.

На пример:

```rust,edition2018,ignore
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

## Итог

1. Если `T: Unpin` (по умолчанию), то `Pin<'a, T>` полностью эквивалентен `&'a mut T`. Другими словами: `Unpin` означает, что этот тип можно перемещать даже при фиксации, поэтому `Pin` не будет оказывать влияния на такой тип.

2. Получение `&mut T` к зафиксированному `T` требует `unsafe`, если `T` не реализует `Unpin`.

3. Большинство типов стандартной библиотеки реализуют `Unpin`. То же самое касается большинства «нормальных» типов, с которыми вы сталкиваетесь в Rust. Футуры, созданные с помощью async/await, является исключением из этого правила.

4. Вы можете добавить `!Unpin` к своему типу, добавив маркер `std::marker::PhantomPinned`.

5. Вы можете зафиксировать объекты на стеке или в куче.

6. Для фиксации `!Unpin` объектов на стеке требуется `unsafe`.

7. Фиксация `!Unpin` объектов в куче не требует `unsafe`. Для этого есть `Box::pin`.

8. Для закрепленных объектов, где `T: !Unpin`, вы должны поддерживать инвариант, согласно которому его память не будет аннулирована или перепрофилирована с момента фиксации до момента вызова `drop`. Это важная часть контракта `Pin`.
